## **[[S01 CORE — Git Fundamentals & Version Control Basics]]**

In Git interviews or technical assessments, you're not judged on how many commands you can recite, but on how you architect version control strategies—choosing the right branching model, explaining why a specific workflow solves collaboration problems, justifying when to rebase vs. merge, and showing that your commit history supports team productivity and code quality. Demonstrating this systems-thinking signals to interviewers that you understand distributed version control, not just command syntax.

| **Topic**                                      | **Subtopics**                                                                                                                                                                                                                                                                                                                                                                                                                  |
| ---------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **[[1.1 Version Control Philosophy & Setup]]** | What is version control; distributed vs. centralized systems; Git philosophy (snapshots vs. deltas); Git vs. SVN/Mercurial; Git lifecycle (working directory, staging area, repository); installing Git (Linux, macOS, Windows); initial configuration (`git config`); user name & email setup; default editor; SSH key generation; GitHub/GitLab/Bitbucket account setup; credential management; `.gitconfig` file structure. |
| **1.2 Repository Basics**                      | Initializing repositories (`git init`); cloning repositories (`git clone`); repository structure (`.git` directory); understanding HEAD; working tree vs. staging area; tracking vs. untracked files; `.gitignore` patterns; global `.gitignore`; checking repository status (`git status`); viewing configuration (`git config --list`).                                                                                      |
| **1.3 Basic Git Operations**                   | Basic commands: clone, commit, push, pull; staging changes (`git add`); committing changes with meaningful messages; viewing commit history (`git log`); log formatting options; commit amending; unstaging changes; discarding working directory changes; viewing differences (`git diff`); staging area vs. working directory diffs; comparing commits.                                                                      |
| **1.4 Branching Fundamentals**                 | Understanding branches; creating branches (`git branch`, `git checkout -b`, `git switch -c`); switching branches; listing branches; branch naming conventions; understanding detached HEAD; branch pointers; lightweight nature of Git branches; local vs. remote branches; tracking branches; deleting branches.                                                                                                              |
| **1.5 Merging Basics**                         | Basic merging concepts; fast-forward merges; three-way merges; merge commit messages; viewing merge history; understanding merge parents; merge conflicts introduction; conflict markers; resolving simple conflicts; aborting merges; merge tools; visual merge tools.                                                                                                                                                        |
| **1.6 Remote Repositories**                    | Understanding remotes; adding remotes (`git remote add`); viewing remotes; fetching from remotes (`git fetch`); pulling from remotes (`git pull`); pushing to remotes (`git push`); upstream branches; tracking remote branches; removing remotes; renaming remotes; fetch vs. pull distinction.                                                                                                                               |
| **1.7 Basic Collaboration**                    | Pull requests/merge requests; code review basics; forking repositories; contributing to open source; cloning vs. forking; keeping forks in sync; basic GitHub/GitLab workflows; issue tracking integration; commit references in issues; basic collaborative etiquette; commit message conventions.                                                                                                                            |
## **S02 APPLIED — Advanced Git Operations, Workflows & Conflict Resolution**

In applied Git assessments, mastery goes beyond knowing basic commands—interviewers are looking for candidates who can architect branching strategies, handle complex merge conflicts, rewrite history responsibly, and choose appropriate workflows for team collaboration. They want to see you justify why interactive rebase cleans up commit history, explain how cherry-pick solves selective feature porting, demonstrate reflog usage for disaster recovery, and show awareness of how workflow choices (GitFlow vs. trunk-based) affect team velocity and release cadence.

|**Topic**|**Subtopics**|
|---|---|
|**2.1 Advanced Branching & Merging**|Branching & merging strategies; merge vs. rebase trade-offs; recursive merge strategy; octopus merges; ours/theirs strategies; merge strategy options; no-fast-forward merges (`--no-ff`); squash merging; branch management at scale; orphan branches; branch protection rules.|
|**2.2 Rebase & History Rewriting**|Interactive rebase (`git rebase -i`); squashing commits; reordering commits; editing commit messages; splitting commits; dropping commits; rebase vs. merge: when to use each; golden rule: never rewrite public history; `--force-with-lease` vs. `--force`; rebasing onto different branches; resolving rebase conflicts; continuing/aborting rebases; rebase merge conflicts vs. regular merge conflicts.|
|**2.3 Cherry-Pick & Selective Changes**|Cherry-picking commits (`git cherry-pick`); use cases: applying bug fixes across branches; cherry-picking ranges; cherry-pick options: `--no-commit`, `--edit`; resolving cherry-pick conflicts (`--abort`, `--continue`, `--quit`); avoiding duplicate commits; when to use cherry-pick vs. merge; cherry-pick in release management.|
|**2.4 Reflog & Disaster Recovery**|Understanding reflog (`git reflog`); reflog shows history of what HEAD pointed to; recovering lost commits; HEAD@{n} notation; reflog for specific branches; reflog expiry (default 90 days); using reflog with cherry-pick for recovery; recovering from hard resets; recovering deleted branches; reflog limitations (local only).|
|**2.5 Stashing & Context Switching**|Stashing changes (`git stash`); stash with message; viewing stash list; applying stashes; popping stashes; stash branching; partial stashing; stashing untracked files; stash patches; dropping stashes; clearing stash; stash use cases (context switching, WIP commits); stash vs. commit trade-offs.|
|**2.6 Advanced Conflict Resolution**|Conflict resolution strategies; understanding conflict markers (`<<<<<<<`, `=======`, `>>>>>>>`); three-way merge understanding; resolving complex conflicts; using merge tools (vimdiff, meld, P4Merge); accepting ours/theirs; checking out specific versions; blame and conflict sources; preventing conflicts (communication, frequent pulls); conflict resolution testing; re-merging after conflicts.|
|**2.7 Git Tags & Releases**|Lightweight vs. annotated tags; creating tags; tagging old commits; pushing tags; deleting tags (local and remote); tag naming conventions (semantic versioning); viewing tags; checking out tags; tag vs. branch distinction; signed tags; tag messages; release workflows; GitHub/GitLab releases; release notes automation.|
|**2.8 Git Bisect & Debugging**|Binary search for bugs (`git bisect`); bisect start, good, bad commands; automated bisect with scripts; bisect skip for untestable commits; bisect visualize; bisect log; bisect reset; finding regression commits; bisect in merge commits; combining bisect with testing frameworks; performance regression hunting.|
## **S03 PROFESSIONAL — Workflows, CI/CD, Team Collaboration & Enterprise Git**

When evaluators explore branching strategies, CI/CD integration, code review practices, and enterprise workflows, they're probing whether you can sustain Git practices at organizational scale. They listen for candidates who understand how to choose between GitFlow and trunk-based development based on team maturity and release cadence, implement GitHub Actions for automated testing and deployment, enforce code quality through pre-commit hooks and review policies, and manage monorepos or multi-repo architectures. Strong answers show that you treat workflow architecture, automation, security, and team education as core engineering responsibilities.

|**Topic**|**Subtopics**|
|---|---|
|**3.1 Git Workflow Strategies**|GitFlow workflow (main, develop, feature, release, hotfix branches); GitFlow for release-based software; trunk-based development (single main branch, short-lived features); trunk-based as requirement for CI/CD; GitHub Flow (simpler than GitFlow); GitLab Flow; choosing workflow based on: team size, release frequency, project complexity; GitFlow vs. trunk-based comparison; when to switch workflows as project matures; feature flags with trunk-based development.|
|**3.2 CI/CD with GitHub Actions** ⭐|GitHub Actions for CI/CD automation; YAML workflow files in `.github/workflows`; workflow triggers (push, pull_request, schedule, workflow_dispatch); jobs, steps, and runners; self-hosted runners; matrix builds (testing across multiple environments); caching dependencies; artifacts and uploads; using secrets and environment variables; GitHub Marketplace actions (11,000+ available); reusable workflows; YAML anchors (2025 feature); OIDC security for deployments; reusable workflow depth (10 levels, 50 calls per run); cache limit increases (beyond 10GB for large projects).|
|**3.3 Code Review & Pull Request Workflows**|Pull request best practices; code review processes; PR templates; review comments; suggesting changes; requesting changes vs. approving; draft PRs; PR status checks; required reviews; CODEOWNERS file; review assignment; automated review requests; PR size guidelines; atomic commits in PRs; rebasing PRs; updating PRs; closing vs. merging; PR etiquette; giving constructive feedback.|
|**3.4 Git Hooks & Automation**|Client-side hooks (pre-commit, pre-push, commit-msg); server-side hooks (pre-receive, post-receive, update); hook scripts; enforcing commit message formats; running tests in hooks; linting with hooks; preventing force pushes; hook management tools (Husky, pre-commit framework); bypassing hooks; hook templates; shared hooks across team; hook execution environment; debugging hooks.|
|**3.5 Advanced Git Configuration**|Global vs. local vs. system config; aliases for common commands; conditional includes; core settings (editor, pager, whitespace); diff and merge tool configuration; color configuration; GPG commit signing; signed commits and tags; commit signing verification; credential helpers; multiple Git identities; includeIf for work/personal separation; rerere (reuse recorded resolution); auto-stash on rebase.|
|**3.6 Submodules & Monorepos**|Git submodules introduction; adding submodules; cloning repos with submodules; updating submodules; submodule workflows; submodule vs. subtree; monorepo management; monorepo tooling (Nx, Turborepo, Bazel); monorepo vs. polyrepo trade-offs; sparse checkout; partial clones; shallow clones for large repos; Git LFS for large files; LFS installation and usage; tracking binary files.|
|**3.7 Security & Access Control**|Repository permissions; branch protection rules; required status checks; require pull request reviews; dismiss stale reviews; require signed commits; restrict who can push; GitHub/GitLab organization security; two-factor authentication; SSH key management; GPG key management; secrets management; preventing credential leaks; git-secrets tool; scanning for secrets; security scanning in CI/CD; dependency vulnerability scanning.|
|**3.8 Performance & Optimization**|Shallow clones (`--depth`); partial clones; sparse checkout for large repos; Git LFS for binaries; maintaining repository health; garbage collection (`git gc`); pruning unreachable objects; repository size management; pack files; delta compression; split repositories; archive old branches; optimizing clone times; reducing history; blobless clones.|

## **S04 — CERTIFICATION, STRATEGIC DECISIONS & ECOSYSTEM**

When interviews reach questions about Git certification, when to use Git vs. alternatives, advanced debugging techniques, and ecosystem tools, evaluators are testing your judgment and breadth. They listen for candidates who can explain when Git's distributed model excels and when centralized systems make sense, demonstrate advanced debugging with blame/bisect/reflog, show awareness of certification paths, and understand Git's position in the broader DevOps ecosystem. Strong candidates acknowledge Git's learning curve and edge cases while showing mastery of its power.

|**Topic**|**Subtopics**|
|---|---|
|**4.1 Git Certification Paths** ⭐|Linux Foundation Git SkillCred ($79, 45-minute exam, non-expiring); performance-based and multiple-choice format; GitLab Certified Professional ($150, hands-on exam); GitLab Certified Fundamentals Associate; GitHub Foundations Certification; preparation courses (IBM, Google, Atlassian, Boot.dev); hands-on labs and practice exams; certification value for career advancement; portfolio projects demonstrating Git mastery.|
|**4.2 When to Use Git**|Distributed team collaboration; open-source projects; code review requirements; branching experimentation; offline work capability; full repository history needs; fast local operations; cryptographic integrity; flexible workflows; integration with modern DevOps tools; GitHub/GitLab ecosystem benefits.|
|**4.3 When to Consider Alternatives**|Very large binary files (consider Git LFS or Perforce); monolithic legacy codebases; teams requiring centralized control; simple linear workflows (SVN might suffice); design file versioning (Abstract, Figma versions); extremely large repositories (100GB+); regulated industries with specific VCS requirements.|
|**4.4 Git vs. Other Version Control**|**SVN** (centralized, simpler learning curve, better for large binaries); **Mercurial** (similar to Git, simpler commands, less adoption); **Perforce** (centralized, large file handling, gaming/multimedia); **Plastic SCM** (GUI-focused, semantic merge); **Fossil** (built-in wiki/tickets, single executable); trade-off matrix: distributed vs. centralized, learning curve, performance, ecosystem, binary handling.|
|**4.5 Advanced Debugging Techniques**|`git bisect` for binary search debugging; `git blame` for code authorship; blame ranges and line history; `git log -S` (pickaxe) for finding when code was added/removed; `git log -G` for regex search; `git grep` for codebase search; `git show` for examining commits; log graph visualization; finding deleted files; tracking file renames; finding bug introductions; performance regression hunting.|
|**4.6 Git Internals & Architecture**|Objects (blobs, trees, commits, tags); SHA-1 hashing (moving to SHA-256); content-addressable storage; pack files and deltas; refs and symbolic refs; HEAD, branches, tags as pointers; .git directory structure; objects database; hooks directory; config file; index file (staging area); understanding how Git stores history; immutability of Git objects; plumbing vs. porcelain commands.|
|**4.7 Git Ecosystem & Tools**|**GUI Clients**: GitKraken, Sourcetree, GitHub Desktop, Tower, Fork; **CLI Enhancements**: tig, lazygit, git-extras, hub/gh (GitHub CLI), glab (GitLab CLI); **Integration Tools**: Jira, Trello, Slack, Microsoft Teams; **Code Hosting**: GitHub, GitLab, Bitbucket, Gitea, Gogs; **Code Review**: Gerrit, Phabricator, Review Board; **CI/CD**: GitHub Actions, GitLab CI, Jenkins, CircleCI, Travis CI; **Analytics**: GitPrime, Code Climate, LinearB.|
|**4.8 Future of Git & Modern Practices**|Git 2.43+ features; partial clone improvements; background maintenance; sparse index; improved merge strategies; scalar for large repos; virtual file systems (VFS for Git); Git in cloud IDEs (GitHub Codespaces, GitPod); AI integration in Git workflows (Copilot, code review automation); GitOps practices; infrastructure as code with Git; continuous deployment evolution; trunk-based development adoption trends.|
