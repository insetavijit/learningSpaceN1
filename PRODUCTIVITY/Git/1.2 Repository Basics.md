
| **Topic**                                      | **Mentor’s Guide**                                                                                            | **Subtopics**                                                                                                                                |
| ---------------------------------------------- | ------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
| **1.2.1 Initializing a Repository**            | Stress when to start fresh vs inherit history. Interviewers look for clarity on repo boundaries and defaults. | `git init`; choosing project root; default branch naming (`main`); reinitialization risks; bare vs non-bare repos; init vs clone decision.   |
| **1.2.2 Cloning Repositories**                 | Show understanding of access methods and performance trade-offs.                                              | `git clone`; HTTPS vs SSH; auth implications; shallow clones (`--depth`); single-branch clones; custom directory names; mirroring.           |
| **1.2.3 Repository Structure**                 | Focus on Git as a database of objects—do not treat `.git` as magic.                                           | `.git` directory purpose; objects, refs, HEAD, index, config; logs; hooks; working tree vs repo data; why not to edit manually.              |
| **1.2.4 Understanding HEAD & Branch Pointers** | Ensure you can reason about what moves when you commit, checkout, or reset.                                   | HEAD as symbolic ref; branches as pointers; commit graph; detached HEAD; checking out commits vs branches; reflog relevance.                 |
| **1.2.5 Working Tree vs Staging Area**         | Emphasize the snapshot model and why staging is a power feature, not overhead.                                | Working directory role; index/staging purpose; `git add` mechanics; partial staging; snapshot mental model; preparing commits.               |
| **1.2.6 File Tracking States**                 | Expect questions on state transitions and cleaning repos.                                                     | Tracked vs untracked; new/modified/staged; deleted files; `git rm`; `git mv`; `git restore`; transitions across states.                      |
| **1.2.7 Ignoring Files with `.gitignore`**     | Show precision in patterns and handling mistakes.                                                             | `.gitignore` syntax; wildcards and negation; directory rules; ignoring tracked files (`--cached`); repo templates; security-sensitive files. |
| **1.2.8 Global Ignore Rules**                  | Differentiate team rules from personal hygiene.                                                               | `core.excludesFile`; user-level ignores; OS/editor artifacts; when not to share; interaction with repo `.gitignore`.                         |
| **1.2.9 Checking Repository Status**           | Treat `git status` as your primary situational awareness tool.                                                | `git status`; short format (`-sb`); staged vs unstaged; untracked files; clean state; reading branch and upstream info.                      |
| **1.2.10 Viewing & Inspecting Configuration**  | Highlight config layering and debugging in real environments.                                                 | `git config --list`; scopes: system/global/local; `--show-origin`; overrides and precedence; common settings; diagnosing issues.             |

Certainly, Boss. Below is a full recall set with **5 questions per topic** for all sections **1.2.1 to 1.2.10**, following your reusable prompt rules and format.

---

### **1.2.1 Initializing a Repository**

###### Q1. What does `git init` fundamentally do in a project directory?

=> `git init` creates a new Git repository by setting up internal tracking metadata. Its purpose is to start version control for a project from a clean baseline. In practice, it prepares the directory to record commits. If used in the wrong place, it can create confusing nested repositories.

###### Q2. How do you choose the correct project root before running `git init`?

=> The project root is the top directory that contains all source files and assets. Its purpose is to define clear repository boundaries. In practice, you initialize where builds and configs live. If chosen incorrectly, unrelated files may be tracked or important files missed.

###### Q3. Why is default branch naming like `main` important during initialization?

=> The default branch name defines the primary line of development. Its purpose is to standardize workflows and tooling expectations. In practice, most teams now use `main` for consistency. If ignored, mismatched branch names can break automation or confuse collaborators.

###### Q4. What risks are associated with reinitializing an existing repository?

=> Reinitializing resets repository metadata without removing files. Its purpose is rarely needed except for recovery. In practice, it can overwrite configs. If done carelessly, it may corrupt history or disconnect links to remotes and hooks.

###### Q5. How do bare and non-bare repositories differ, and when is each used?

=> A non-bare repo has a working tree, while a bare repo stores only Git data. Their purpose is development versus sharing. In practice, bare repos act as central remotes. If you use bare repos for coding, you lose a working directory.

---

### **1.2.2 Cloning Repositories**

###### Q6. What does `git clone` provide beyond just copying files?

=> `git clone` copies the full repository including commit history and remote links. Its purpose is to reproduce an exact working copy for collaboration. In practice, it sets up tracking automatically. If you copy files manually, you lose history and Git context.

###### Q7. How do HTTPS and SSH cloning differ in authentication purpose?

=> HTTPS uses username or tokens, while SSH uses key-based authentication. Their purpose is secure remote access. In practice, SSH avoids repeated logins. If misconfigured, HTTPS can expose credentials or SSH can block access entirely.

###### Q8. Why would you use a shallow clone with `--depth`?

=> A shallow clone limits history to recent commits. Its purpose is faster downloads and reduced storage. In practice, it helps in CI pipelines. If used for development, missing history can break merges or debugging.

###### Q9. What is the value of single-branch cloning?

=> Single-branch cloning fetches only one branch instead of all. Its purpose is efficiency when other branches are irrelevant. In practice, it saves time and space. If you later need other branches, you must fetch them explicitly.

###### Q10. When is mirroring a repository with `--mirror` appropriate?

=> Mirroring copies all refs and branches exactly as-is. Its purpose is full backups or migrations. In practice, it is used for server replication. If used for normal work, it creates a bare structure unsuitable for development.

---

### **1.2.3 Repository Structure**

###### Q11. Why is Git described as a database of objects?

=> Git stores content as immutable objects identified by hashes. Its purpose is reliable version tracking and integrity. In practice, every commit and file becomes an object. If misunderstood, users treat Git as magic and misuse its storage.

###### Q12. What role does the `.git` directory play in a repository?

=> The `.git` directory contains all metadata and history. Its purpose is to act as the engine of Git operations. In practice, commands read and write here. If damaged or edited manually, the repository can become unusable.

###### Q13. What are refs and why are they important?

=> Refs are pointers to commits, such as branches and tags. Their purpose is to name important points in history. In practice, they move as you commit. If corrupted, Git loses track of branches.

###### Q14. How does the index fit into repository structure?

=> The index stores the staged snapshot before a commit. Its purpose is to prepare controlled changes. In practice, it bridges working files and commits. If ignored, users lose the power of selective commits.

###### Q15. Why should developers avoid editing `.git` files manually?

=> `.git` files define internal state and references. Their purpose is automation by Git itself. In practice, manual edits risk inconsistency. If changed wrongly, history and refs can be corrupted beyond easy repair.

---

### **1.2.4 Understanding HEAD & Branch Pointers**

###### Q16. What is HEAD in Git and what does it usually point to?

=> HEAD is a symbolic reference to the current branch or commit. Its purpose is to mark where new commits attach. In practice, it points to a branch tip. If detached, commits may be lost.

###### Q17. How are branches implemented internally in Git?

=> Branches are simple pointers to commits. Their purpose is to name development lines. In practice, they move forward with commits. If misunderstood, users think branches copy files instead of references.

###### Q18. What happens to HEAD when you checkout a commit directly?

=> HEAD points directly to a commit instead of a branch. Its purpose is to inspect past states. In practice, this is called detached HEAD. If you commit here without a branch, work may be discarded.

###### Q19. How does the commit graph help reason about history?

=> The commit graph links commits by parent relationships. Its purpose is to model project evolution. In practice, it explains merges and ancestry. If ignored, history becomes hard to interpret.

###### Q20. Why is reflog useful when working with HEAD movements?

=> Reflog records where HEAD has pointed recently. Its purpose is recovery from mistakes. In practice, it helps restore lost commits. If overlooked, accidental resets can cause permanent loss.

---

### **1.2.5 Working Tree vs Staging Area**

###### Q21. What is the working tree in Git?

=> The working tree contains the actual files you edit. Its purpose is to reflect the current checked-out state. In practice, it is your sandbox for changes. If confused with commits, changes may be lost.

###### Q22. Why does Git use a staging area before commits?

=> The staging area holds the next snapshot to commit. Its purpose is controlled versioning. In practice, it allows selective changes. If skipped, commits may include unwanted edits.

###### Q23. How does `git add` interact with the snapshot model?

=> `git add` updates the staged snapshot, not just marks files. Its purpose is to build the next commit image. In practice, it captures current content. If misunderstood, users expect it to track future edits automatically.

###### Q24. What is partial staging and why is it powerful?

=> Partial staging lets you stage parts of a file. Its purpose is fine-grained commits. In practice, it supports clean history. If ignored, commits become large and unclear.

###### Q25. What risk arises from confusing staging with committing?

=> Staging does not record history until committed. Its purpose is preparation, not storage. In practice, unstaged work can be lost. If assumed saved, crashes or resets may erase changes.

---

### **1.2.6 File Tracking States**

###### Q26. What does it mean for a file to be untracked in Git?

=> An untracked file is not yet under version control. Its purpose is to signal new content. In practice, Git ignores it until added. If forgotten, important files may never be committed.

###### Q27. How do files transition from modified to staged?

=> Modified files change in the working tree and become staged with `git add`. Their purpose is to move toward committing. In practice, this prepares snapshots. If skipped, changes remain uncommitted.

###### Q28. What is the role of `git rm` in file states?

=> `git rm` stages file deletion for the next commit. Its purpose is to track removals cleanly. In practice, it updates history. If you delete manually without staging, state becomes inconsistent.

###### Q29. How does `git mv` differ from moving files in the OS?

=> `git mv` moves and stages the change in one step. Its purpose is convenience and clarity. In practice, Git still tracks content. If moved manually, you must stage both delete and add.

###### Q30. Why is understanding state transitions critical for cleanup?

=> State transitions show what will be committed or ignored. Their purpose is awareness. In practice, they guide cleanup commands. If misunderstood, repos stay cluttered or lose files.

---

### **1.2.7 Ignoring Files with `.gitignore`**

###### Q31. What is the main purpose of a `.gitignore` file?

=> `.gitignore` tells Git which files not to track. Its purpose is to avoid committing noise or secrets. In practice, it filters builds and logs. If misused, sensitive files may leak.

###### Q32. How do wildcards and patterns work in `.gitignore`?

=> Patterns match file paths using rules and wildcards. Their purpose is flexible ignoring. In practice, they target file groups. If written incorrectly, important files may be ignored.

###### Q33. Why does `.gitignore` not affect already tracked files?

=> Git prioritizes history over ignore rules. Its purpose is to prevent silent data loss. In practice, tracked files stay tracked. If misunderstood, users think ignores are broken.

###### Q34. How do you stop tracking a file while keeping it locally?

=> You remove it from Git using cached removal. Its purpose is to untrack without deleting. In practice, it cleans history. If skipped, sensitive files remain committed.

###### Q35. What risk comes from poor `.gitignore` hygiene in teams?

=> Poor rules lead to inconsistent repositories. Their purpose is shared cleanliness. In practice, missing rules cause clutter. If unmanaged, repos become noisy and insecure.

---

### **1.2.8 Global Ignore Rules**

###### Q36. What are global ignore rules in Git?

=> Global ignores apply user-wide across all repositories. Their purpose is personal cleanup. In practice, they hide OS and editor files. If shared expectations rely on them, teams get inconsistent results.

###### Q37. How is `core.excludesFile` used in practice?

=> It points Git to a global ignore file. Its purpose is centralized personal rules. In practice, users configure it once. If forgotten, ignores may not work.

###### Q38. Why should global ignores not replace repo `.gitignore`?

=> Global ignores are invisible to teammates. Their purpose is personal, not shared. In practice, repo rules define team standards. If relied upon, unwanted files get committed.

###### Q39. What kinds of files belong in global ignores?

=> Editor temp files and OS artifacts fit global ignores. Their purpose is noise reduction. In practice, they differ per user. If added to repo ignores, rules become bloated.

###### Q40. What risk arises from mixing personal and team ignore rules?

=> Mixing blurs responsibility between user and repo. Its purpose is separation of concerns. In practice, confusion causes leaks. If unmanaged, ignores become unreliable.

---

### **1.2.9 Checking Repository Status**

###### Q41. What information does `git status` primarily provide?

=> It shows changes in working and staging areas. Its purpose is situational awareness. In practice, it guides next actions. If ignored, mistakes happen easily.

###### Q42. Why is the short format `git status -sb` useful?

=> It gives compact branch and change info. Its purpose is fast scanning. In practice, it fits daily workflows. If avoided, users miss upstream and branch context.

###### Q43. How does `git status` distinguish staged and unstaged changes?

=> It groups files by readiness for commit. Its purpose is clarity. In practice, it prevents wrong commits. If misunderstood, users commit partial work.

###### Q44. What does a clean status indicate?

=> A clean status means no pending changes. Its purpose is confirmation. In practice, it signals safe operations. If assumed incorrectly, work may be lost.

###### Q45. Why should `git status` be run before most commands?

=> It reveals the repo’s current state. Its purpose is risk reduction. In practice, it prevents errors. If skipped, destructive commands may harm work.

---

### **1.2.10 Viewing & Inspecting Configuration**

###### Q46. What does `git config --list` show?

=> It lists all active Git configuration values. Its purpose is visibility into behavior. In practice, it reveals current settings. If ignored, hidden configs cause surprises.

###### Q47. How do system, global, and local scopes differ?

=> Scopes define where settings apply. Their purpose is layered control. In practice, local overrides global. If misunderstood, changes seem ineffective.

###### Q48. Why is `--show-origin` important in debugging configs?

=> It shows where each setting comes from. Its purpose is traceability. In practice, it speeds debugging. If skipped, conflicts remain unclear.

###### Q49. What role do overrides play in Git configuration?

=> Overrides allow specific settings to replace defaults. Their purpose is flexibility. In practice, projects tune behavior. If abused, environments become inconsistent.

###### Q50. Why is understanding config precedence critical in teams?

=> Precedence defines which values win. Its purpose is predictability. In practice, it avoids confusion. If ignored, developers struggle with mismatched behavior.

---

If you want, Boss, I can next convert these into **flashcards**, **Notion-ready tables**, or a **spaced review schedule** aligned with your StudyMap framework.