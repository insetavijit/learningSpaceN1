
| **Topic**                              | **Subtopics**                                                                                                                                       |
| -------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| **1.1.1 [[What is Version Control]]**  | Purpose of version control; tracking file history; collaboration workflows; change auditing; rollback and recovery; use cases in software projects. |
| **1.1.2 VC System Models**             | Centralized vs distributed systems; architecture comparison; pros and cons; offline work; scalability; examples: SVN, Git, Mercurial.               |
| **1.1.3 Git Philosophy**               | Snapshots vs deltas; content-addressable storage; commits as immutable objects; branching as lightweight pointers; design goals.                    |
| **1.1.4 Git vs Other VCS**             | Git vs SVN; Git vs Mercurial; performance; branching/merging models; ecosystem and tooling; industry adoption.                                      |
| **1.1.5 Git Lifecycle**                | Working directory; staging area (index); local repository; commit flow; file states (untracked, modified, staged, committed); basic mental model.   |
| **1.1.6 Installation & Setup**         | Installing Git on Linux, macOS, Windows; package managers vs installers; verifying install; updating Git versions.                                  |
| **1.1.7 Initial Configuration**        | `git config` scopes (system, global, local); setting user.name and user.email; default editor; line endings (core.autocrlf); aliases.               |
| **1.1.8 Authentication & Credentials** | SSH key generation; adding keys to GitHub/GitLab/Bitbucket; HTTPS vs SSH; credential helpers; secure storage of tokens/passwords.                   |
| **1.1.9 Platform Accounts Setup**      | Creating accounts on GitHub/GitLab/Bitbucket; profile basics; linking SSH keys; repository visibility; organization vs personal repos.              |
| **1.1.10 `.gitconfig` Structure**      | `.gitconfig` file layout; sections and keys; includes; per-project overrides; best practices for maintainable config.                               |

---

### Questions 
###### Q1. What is version control, and what risks arise when projects avoid using it?

=> Version control is a system that records changes to files so you can track progress, collaborate, and recover from mistakes. Without it, files get overwritten, errors are hard to fix, and teamwork quickly becomes chaotic and unreliable.

###### Q2. Why is tracking file history central to version control, and what happens without history?

=> File history lets you see who changed what and when, helping debugging and learning. Without history, finding the cause of bugs becomes guesswork, and teams lose confidence in their changes.

###### Q3. What defines a centralized version control system, and why can it become a bottleneck?

=> A centralized system uses one main server for all changes, which is simple to manage. However, if the server or network fails, everyone is blocked from working, slowing teams and risking downtime.

###### Q4. What makes a distributed system like Git different, and why is that more resilient?

=> In distributed systems, every user has a full copy of the repository, allowing offline work. This makes teams resilient because work continues even if servers are down.

###### Q5. What does it mean that Git uses snapshots instead of deltas, and why does it matter?

=> Git stores full snapshots of files at each commit rather than only differences. This makes history reliable and fast to access, while delta systems can become complex and slower over time.

###### Q6. Why are Git commits considered immutable, and what risk exists if history changes?

=> Commits never change once created, which protects trust in history. If history were mutable, teams could lose confidence, and collaboration would become unsafe.

###### Q7. Why is Git often preferred over SVN in modern development workflows?

=> Git allows fast local work, easy branching, and offline commits, making developers more productive. SVN depends on a server, which slows daily work and limits flexibility.

###### Q8. How does Git’s ecosystem influence its industry adoption compared to other systems?

=> Git has massive community support and tools like GitHub and CI systems. Smaller ecosystems limit learning, integrations, and hiring, making long-term growth harder.

###### Q9. What are the three main areas in Git’s lifecycle, and why understand this model?

=> The working directory, staging area, and repository form Git’s mental model. Understanding them prevents confusion and helps you control exactly what goes into each commit.

###### Q10. Why is the staging area powerful, and what happens if users ignore it?

=> The staging area lets you choose precise changes for a commit. Ignoring it leads to messy commits, harder reviews, and unclear project history.

###### Q11. Why should Git be installed differently on Linux and Windows systems?

=> Linux uses package managers while Windows uses installers. Using wrong methods can cause outdated versions or broken paths, making Git unreliable in daily work.

###### Q12. Why is verifying Git installation after setup important for beginners?

=> Verifying ensures Git works before real work begins. Without checking, users may hit errors later and waste time debugging basic setup issues.

###### Q13. Why must user name and email be configured before making commits?

=> These values identify who made each change. Without them, history becomes unclear, accountability is lost, and collaboration across teams becomes confusing.

###### Q14. Why do Git config scopes matter, and what happens if they are misunderstood?

=> System, global, and local scopes control where settings apply. Misunderstanding them causes unexpected behavior across projects, frustrating users.

###### Q15. Why is SSH preferred over HTTPS for authentication in daily Git use?

=> SSH enables secure, passwordless access after setup, making workflows smoother. HTTPS often requires repeated credentials, slowing work and causing frustration.

###### Q16. What risk exists if credentials are stored insecurely or shared carelessly?

=> Exposed tokens allow attackers to modify or steal code, damaging projects and trust. Secure handling is critical for team safety.

###### Q17. Why are hosting platforms like GitHub essential for collaboration today?

=> They host repositories, reviews, and issues in one place. Without platforms, sharing code and managing teamwork becomes fragmented and inefficient.

###### Q18. Why does repository visibility matter, and what goes wrong if misconfigured?

=> Visibility controls who can see code. Wrong settings may expose private work or block collaborators, harming security or productivity.

###### Q19. What is the purpose of the `.gitconfig` file in daily Git usage?

=> It stores settings that control Git behavior. Without understanding it, users struggle to customize workflows and debug strange behavior.

###### Q20. Why are includes and per-project overrides useful in `.gitconfig` management?

=> They keep configs organized and adaptable for different projects. Without them, configs grow messy and hard to maintain as setups evolve.
