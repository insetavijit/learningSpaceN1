|**Topic**|**Mentor’s Guide**|**Subtopics**|
|---|---|---|
|**1.4.1 Branch Concepts & Purpose**|Frame branches as cheap pointers enabling parallelism, not copies of code. Interviewers expect clear use cases.|What branches represent; isolation of work; parallel development; feature/fix/experiment flows; benefits over linear history; relation to commits and DAG.|
|**1.4.2 Creating Branches**|Show fluency with both legacy and modern commands and choosing correct start points.|`git branch`; `git checkout -b`; `git switch -c`; branching from HEAD vs specific commits/tags; creating from remote branches; naming at creation.|
|**1.4.3 Switching Branches**|Emphasize safety and working tree impact when moving between branches.|`git checkout` vs `git switch`; updating working tree and index; handling uncommitted changes; `--detach`; common pitfalls and recovery.|
|**1.4.4 Listing & Inspecting Branches**|Treat branch inspection as situational awareness in multi-branch repos.|`git branch`; current branch indicator; verbose (`-vv`); showing last commit; ahead/behind vs upstream; filtering and sorting branches.|
|**1.4.5 Branch Naming Conventions**|Connect naming to collaboration, tooling, and automation.|Descriptive names; prefixes (`feature/`, `bugfix/`, `hotfix/`); ticket IDs; kebab vs slash styles; team standards; CI/CD and tooling support.|
|**1.4.6 Branch Pointers & Lightweight Nature**|Ensure you can explain _why_ branches are cheap in Git.|Branches as refs to commits; pointer movement on commit; cost of creation; comparison with heavyweight VCS branches; impact on performance.|
|**1.4.7 Detached HEAD Explained**|Expect this as a common trap — explain calmly how to recover.|Meaning of detached HEAD; how it occurs; temporary exploration; risks of losing commits; creating a branch to save work; reflog recovery.|
|**1.4.8 Local vs Remote Branches**|Clarify that remote branches are references, not live branches.|Local branches vs remote-tracking (`origin/main`); read-only nature; fetch updates; mapping to remotes; common misconceptions.|
|**1.4.9 Tracking Branches**|Highlight how tracking simplifies daily sync operations.|Upstream configuration; `--set-upstream-to`; tracking on creation; checking upstream; push/pull defaults; ahead/behind indicators.|
|**1.4.10 Deleting Branches**|Stress cleanup discipline and safety checks.|Safe deletion of merged branches (`-d`); force deletion (`-D`); pruning stale remotes; deleting remote branches; hygiene practices.|

### **1.4.1 Branch Concepts & Purpose**

###### Q1. What does a branch represent in Git, and why is it not a copy of code?

=> A branch is a pointer to a commit in Git’s history. Its purpose is to mark a line of development without duplicating files. In practice, it enables parallel work on the same codebase. If seen as a copy, users misunderstand how lightweight and flexible branching really is.

###### Q2. How do branches enable isolation and parallel development in teams?

=> Branches isolate work by pointing to different commits while sharing history. Their purpose is to let features, fixes, and experiments progress independently. In practice, teams work without interfering with each other. If avoided, teams are forced into risky linear development.

###### Q3. Why are branches preferred over a strictly linear history?

=> Branches allow multiple lines of change instead of one path. Their purpose is to support experimentation and safe integration. In practice, they reduce conflict and risk. If only linear history is used, changes collide and slow teams down.

###### Q4. How are branches connected to commits and the DAG model?

=> Branches point into the commit DAG that models history. Their purpose is to name important tips in that graph. In practice, moving through branches is moving through the DAG. If this link is unclear, history navigation becomes confusing.

---

### **1.4.2 Creating Branches**

###### Q5. What are the different ways to create a branch in Git, and why do they exist?

=> Git offers `git branch`, `git checkout -b`, and `git switch -c` to create branches. Their purpose is to support both legacy and modern workflows. In practice, they differ mainly in clarity. If chosen poorly, commands become harder to reason about.

###### Q6. Why does the starting point of a new branch matter?

=> A branch starts from a specific commit that defines its base. Its purpose is to decide what history and code it builds on. In practice, branching from the wrong commit causes missing or extra changes. If ignored, merges become messy.

###### Q7. When should you create a branch from a remote branch?

=> You create from a remote branch to continue shared work locally. Its purpose is to align your branch with team progress. In practice, it sets up collaboration. If you branch from outdated local history, you may diverge unnecessarily.

###### Q8. Why is naming at creation time considered a good practice?

=> Naming at creation gives immediate identity to the branch. Its purpose is clarity and traceability. In practice, it signals intent to others. If delayed or vague, branches become hard to manage.

---

### **1.4.3 Switching Branches**

###### Q9. What happens to the working tree when you switch branches?

=> Git updates files to match the target branch’s snapshot. Its purpose is to reflect the checked-out state. In practice, your files change instantly. If you have conflicting uncommitted changes, switching can fail or cause confusion.

###### Q10. Why is `git switch` preferred over `git checkout` for branch changes?

=> `git switch` focuses only on branch switching. Its purpose is safer and clearer intent. In practice, it avoids overload of `checkout`. If you rely on old habits, mistakes like detaching HEAD become more likely.

###### Q11. How should you handle uncommitted changes before switching branches?

=> Uncommitted changes should be committed, stashed, or discarded. Their purpose is to keep transitions safe. In practice, this avoids conflicts. If ignored, changes may block switching or be mixed into the wrong branch.

###### Q12. What does `--detach` do when switching?

=> `--detach` moves HEAD to a commit without a branch. Its purpose is temporary exploration. In practice, it lets you inspect old states. If you commit here without care, work may be lost.

---

### **1.4.4 Listing & Inspecting Branches**

###### Q13. Why is listing branches part of situational awareness?

=> Listing branches shows what lines of work exist locally. Its purpose is awareness in complex repos. In practice, it prevents working on the wrong branch. If skipped, developers lose context easily.

###### Q14. What does the current branch indicator tell you?

=> It marks which branch HEAD is pointing to. Its purpose is to confirm your working context. In practice, it avoids accidental commits on wrong branches. If ignored, mistakes enter history.

###### Q15. How does verbose branch listing with `-vv` help daily work?

=> Verbose listing shows upstream and ahead or behind status. Its purpose is sync awareness. In practice, it tells if you need to pull or push. If unused, branches silently drift.

###### Q16. Why is inspecting the last commit on branches useful?

=> The last commit summarizes recent activity on each branch. Its purpose is quick assessment of relevance. In practice, it helps choose where to work. If ignored, stale branches linger.

---

### **1.4.5 Branch Naming Conventions**

###### Q17. Why do teams enforce branch naming conventions?

=> Naming conventions standardize how branches communicate intent. Their purpose is collaboration and automation. In practice, tools rely on predictable names. If inconsistent, humans and systems both get confused.

###### Q18. How do prefixes like `feature/` or `bugfix/` add value?

=> Prefixes categorize branches by purpose. Their purpose is quick understanding of intent. In practice, they help reviewers and CI rules. If absent, branches look alike and lose meaning.

###### Q19. Why include ticket IDs or descriptors in branch names?

=> Ticket IDs link code to tracked work. Their purpose is traceability. In practice, they connect commits to issues. If omitted, audits and reviews lose context.

###### Q20. What risks come from poorly chosen branch names?

=> Poor names hide purpose and break tooling rules. Their purpose is clarity, not decoration. In practice, bad names slow reviews. If tolerated, repo hygiene degrades.

---

### **1.4.6 Branch Pointers & Lightweight Nature**

###### Q21. Why are Git branches considered cheap to create?

=> A branch is just a small reference to a commit. Its purpose is to name a point in history. In practice, creation is instant and low cost. If thought expensive, users avoid branching unnecessarily.

###### Q22. How does a branch pointer move when you commit?

=> The pointer advances to the new commit. Its purpose is to mark progress on that line. In practice, it tracks development. If misunderstood, users think commits modify the branch itself.

###### Q23. How do Git branches differ from heavyweight branches in older VCS tools?

=> Older systems copied files, while Git moves pointers. Their purpose is efficiency versus duplication. In practice, Git scales better. If ignored, Git’s design advantage is lost.

###### Q24. Why does the lightweight model improve performance and workflow?

=> Lightweight branches reduce storage and speed operations. Their purpose is to encourage experimentation. In practice, teams branch freely. If misunderstood, workflows become overly cautious.

---

### **1.4.7 Detached HEAD Explained**

###### Q25. What does it mean to be in a detached HEAD state?

=> Detached HEAD means HEAD points directly to a commit, not a branch. Its purpose is temporary inspection. In practice, it allows exploration. If misunderstood, commits may become unreachable.

###### Q26. How does a detached HEAD state usually occur?

=> It happens when checking out a commit or tag directly. Its purpose is to view past states. In practice, it is common during debugging. If unrecognized, users panic at warnings.

###### Q27. Why is detached HEAD considered risky for new commits?

=> Commits are not attached to any branch. Its purpose is not long-term work. In practice, they can be lost. If ignored, valuable work disappears.

###### Q28. How do you safely recover or save work from detached HEAD?

=> You create a new branch at that commit. Its purpose is to anchor work in history. In practice, this preserves changes. If skipped, recovery becomes harder.

---

### **1.4.8 Local vs Remote Branches**

###### Q29. What is the difference between a local branch and a remote-tracking branch?

=> A local branch is where you commit, while a remote-tracking branch reflects a remote state. Their purpose is work versus observation. In practice, `origin/main` is read-only. If confused, users try to commit to it.

###### Q30. Why are remote branches described as references, not live branches?

=> They only record the last fetched state. Their purpose is to mirror remotes locally. In practice, they update on fetch. If seen as live, users expect instant sync.

###### Q31. How do remote-tracking branches get updated?

=> They update when you fetch from the remote. Their purpose is to reflect remote progress. In practice, fetch refreshes them. If you never fetch, they become stale.

###### Q32. What common misconception causes trouble with remote branches?

=> Thinking they are writable like local branches. Its purpose is clarity of roles. In practice, this leads to wrong commands. If not corrected, syncing becomes confusing.

---

### **1.4.9 Tracking Branches**

###### Q33. What is a tracking branch in Git?

=> A tracking branch is linked to an upstream remote branch. Its purpose is to simplify sync operations. In practice, push and pull know their targets. If unset, commands need extra arguments.

###### Q34. Why does setting upstream improve daily workflows?

=> It removes ambiguity about where changes go. Its purpose is automation and safety. In practice, simple `git pull` works. If ignored, mistakes in syncing occur.

###### Q35. How do ahead and behind indicators help with tracking?

=> They show how your branch diverges from upstream. Their purpose is awareness. In practice, they guide when to push or pull. If ignored, branches silently drift apart.

###### Q36. What risk comes from working without tracking configured?

=> You may push to or pull from the wrong branch. Its purpose is correctness. In practice, this creates confusion. If tolerated, collaboration breaks down.

---

### **1.4.10 Deleting Branches**

###### Q37. Why should merged branches be deleted regularly?

=> Deleting merged branches keeps the repo clean. Its purpose is hygiene and clarity. In practice, it reduces clutter. If skipped, stale branches pile up.

###### Q38. What is the difference between safe deletion `-d` and force deletion `-D`?

=> Safe deletion checks merge status, while force ignores it. Their purpose is protection versus override. In practice, `-d` prevents loss. If you use `-D` carelessly, work can vanish.

###### Q39. Why is pruning remote branches important?

=> Pruning removes references to deleted remote branches. Its purpose is accurate state. In practice, it avoids stale listings. If ignored, remote clutter remains.

###### Q40. What discipline should guide branch deletion in teams?

=> Only delete when work is merged or truly obsolete. Its purpose is safety. In practice, teams review before deletion. If rushed, important branches may be lost.

---

If you want, Boss, I can next consolidate **Sections 1.3 and 1.4** into a single **Active Recall pack**, or transform these into **Notion/Anki-ready flashcards** aligned with your StudyMap.